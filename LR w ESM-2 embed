{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "511449e6",
   "metadata": {
    "papermill": {
     "duration": 0.003383,
     "end_time": "2025-12-13T13:36:33.265721",
     "exception": false,
     "start_time": "2025-12-13T13:36:33.262338",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Logistic Regression with ESM-2 embeddings\n",
    "\n",
    "Idea:\n",
    "- Model: OneVsRestClassifier(LogisticRegression) --> train one Logistic Regression model for one class\n",
    "- Features: PCA(n_components=100) --> PCA.fit_transform(ESM-2 embeddings)\n",
    "- Labels: Three sets for three ontologies (P, C, F)\n",
    "    - P has 16858 classes\n",
    "    - C has 2651 classes\n",
    "    - F has 6616 classes\n",
    "\n",
    "Future direction:\n",
    "- Model --> MLP\n",
    "- Features --> full embeddings\n",
    "\n",
    "References:\n",
    "- (EDA + OneVsRestClassifier) https://www.kaggle.com/code/analyticaobscura/cafa-6-decoding-protein-mysteries\n",
    "- (ESM-2 320-D embeddings) https://www.kaggle.com/code/dalloliogm/compute-protein-embeddings-with-esm2-esm-c/notebook\n",
    "- (Optional ProtT5 1024-D embeddings) https://www.kaggle.com/code/ahsuna123/t5-embedding-calculation-cafa-6/output?select=train_ids.npy\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "55c47c84",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:33.271873Z",
     "iopub.status.busy": "2025-12-13T13:36:33.271629Z",
     "iopub.status.idle": "2025-12-13T13:36:40.032200Z",
     "shell.execute_reply": "2025-12-13T13:36:40.031223Z"
    },
    "papermill": {
     "duration": 6.76525,
     "end_time": "2025-12-13T13:36:40.033718",
     "exception": false,
     "start_time": "2025-12-13T13:36:33.268468",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "!pip install biopython > /dev/null"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "929a5c78",
   "metadata": {
    "papermill": {
     "duration": 0.00266,
     "end_time": "2025-12-13T13:36:40.039360",
     "exception": false,
     "start_time": "2025-12-13T13:36:40.036700",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 1: Load CAFA6 files\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "4b169597",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:40.045963Z",
     "iopub.status.busy": "2025-12-13T13:36:40.045434Z",
     "iopub.status.idle": "2025-12-13T13:36:40.049178Z",
     "shell.execute_reply": "2025-12-13T13:36:40.048600Z"
    },
    "papermill": {
     "duration": 0.00828,
     "end_time": "2025-12-13T13:36:40.050220",
     "exception": false,
     "start_time": "2025-12-13T13:36:40.041940",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# CAFA6 file paths\n",
    "TRAIN_TERMS = \"/kaggle/input/cafa-6-protein-function-prediction/Train/train_terms.tsv\"\n",
    "TRAIN_SEQ = \"/kaggle/input/cafa-6-protein-function-prediction/Train/train_sequences.fasta\"\n",
    "TEST_SEQ = \"/kaggle/input/cafa-6-protein-function-prediction/Test/testsuperset.fasta\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "6fb61222",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:40.056328Z",
     "iopub.status.busy": "2025-12-13T13:36:40.055976Z",
     "iopub.status.idle": "2025-12-13T13:36:43.470284Z",
     "shell.execute_reply": "2025-12-13T13:36:43.469485Z"
    },
    "papermill": {
     "duration": 3.418692,
     "end_time": "2025-12-13T13:36:43.471472",
     "exception": false,
     "start_time": "2025-12-13T13:36:40.052780",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loaded 82404 train and 224309 test sequences\n"
     ]
    }
   ],
   "source": [
    "from Bio import SeqIO \n",
    "\n",
    "# Dict {entryId, seq}\n",
    "train_sequences = {rec.id: str(rec.seq) for rec in SeqIO.parse(TRAIN_SEQ, 'fasta')}\n",
    "test_sequences  = {rec.id: str(rec.seq) for rec in SeqIO.parse(TEST_SEQ,  'fasta')}\n",
    "\n",
    "print(f'Loaded {len(train_sequences)} train and {len(test_sequences)} test sequences')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "3e675452",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:43.478093Z",
     "iopub.status.busy": "2025-12-13T13:36:43.477860Z",
     "iopub.status.idle": "2025-12-13T13:36:43.543634Z",
     "shell.execute_reply": "2025-12-13T13:36:43.542872Z"
    },
    "papermill": {
     "duration": 0.070433,
     "end_time": "2025-12-13T13:36:43.544784",
     "exception": false,
     "start_time": "2025-12-13T13:36:43.474351",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train dict: ('sp|A0A0C5B5G6|MOTSC_HUMAN', 'MRWQEMGYIFYPRKLR')\n",
      "Test dict: ('A0A0C5B5G6', 'MRWQEMGYIFYPRKLR')\n"
     ]
    }
   ],
   "source": [
    "print(\"Train dict:\", list(train_sequences.items())[0])\n",
    "print(\"Test dict:\", list(test_sequences.items())[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "1d181685",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:43.551243Z",
     "iopub.status.busy": "2025-12-13T13:36:43.551033Z",
     "iopub.status.idle": "2025-12-13T13:36:43.571401Z",
     "shell.execute_reply": "2025-12-13T13:36:43.570690Z"
    },
    "papermill": {
     "duration": 0.024858,
     "end_time": "2025-12-13T13:36:43.572506",
     "exception": false,
     "start_time": "2025-12-13T13:36:43.547648",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "train_ids = [i.split('|')[1] for i in train_sequences.keys()]\n",
    "test_ids = list(test_sequences.keys())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "c0ab7b0e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:43.578740Z",
     "iopub.status.busy": "2025-12-13T13:36:43.578543Z",
     "iopub.status.idle": "2025-12-13T13:36:43.582587Z",
     "shell.execute_reply": "2025-12-13T13:36:43.581866Z"
    },
    "papermill": {
     "duration": 0.008449,
     "end_time": "2025-12-13T13:36:43.583737",
     "exception": false,
     "start_time": "2025-12-13T13:36:43.575288",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "train_ids[0:10]: ['A0A0C5B5G6', 'A0JNW5', 'A0JP26', 'A0PK11', 'A1A4S6', 'A1A519', 'A1L190', 'A1L3X0', 'A1X283', 'A2A2Y4']\n",
      "test_ids[0:10]: ['A0A0C5B5G6', 'A0A1B0GTW7', 'A0JNW5', 'A0JP26', 'A0PK11', 'A1A4S6', 'A1A519', 'A1L190', 'A1L3X0', 'A1X283']\n"
     ]
    }
   ],
   "source": [
    "print(\"train_ids[0:10]:\", train_ids[0:10])\n",
    "print(\"test_ids[0:10]:\", test_ids[0:10])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "63714a2d",
   "metadata": {
    "papermill": {
     "duration": 0.002628,
     "end_time": "2025-12-13T13:36:43.589103",
     "exception": false,
     "start_time": "2025-12-13T13:36:43.586475",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 2: Feature extraction\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "f9f4db3a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:43.595424Z",
     "iopub.status.busy": "2025-12-13T13:36:43.594921Z",
     "iopub.status.idle": "2025-12-13T13:36:43.598332Z",
     "shell.execute_reply": "2025-12-13T13:36:43.597648Z"
    },
    "papermill": {
     "duration": 0.007742,
     "end_time": "2025-12-13T13:36:43.599432",
     "exception": false,
     "start_time": "2025-12-13T13:36:43.591690",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Embeddings file paths\n",
    "ESM_EMBEDDINGS = \"/kaggle/input/cafa6-esm2-650m-embedding/esm2_650M\"\n",
    "TRAIN_EMBEDDINGS = ESM_EMBEDDINGS + \"/train_sequences_emb.npy\"\n",
    "TEST_EMBEDDINGS = ESM_EMBEDDINGS + \"/testsuperset_emb.npy\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "4c2f1dc0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:43.605501Z",
     "iopub.status.busy": "2025-12-13T13:36:43.605309Z",
     "iopub.status.idle": "2025-12-13T13:36:47.639705Z",
     "shell.execute_reply": "2025-12-13T13:36:47.638894Z"
    },
    "papermill": {
     "duration": 4.039064,
     "end_time": "2025-12-13T13:36:47.641171",
     "exception": false,
     "start_time": "2025-12-13T13:36:43.602107",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "# Load embeddings\n",
    "X_train = np.load(TRAIN_EMBEDDINGS)\n",
    "X_test = np.load(TEST_EMBEDDINGS)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "881fe608",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:47.648463Z",
     "iopub.status.busy": "2025-12-13T13:36:47.647820Z",
     "iopub.status.idle": "2025-12-13T13:36:47.651606Z",
     "shell.execute_reply": "2025-12-13T13:36:47.650877Z"
    },
    "papermill": {
     "duration": 0.008488,
     "end_time": "2025-12-13T13:36:47.652666",
     "exception": false,
     "start_time": "2025-12-13T13:36:47.644178",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X_train shape: (82404, 1280)\n",
      "X_test shape: (224309, 1280)\n"
     ]
    }
   ],
   "source": [
    "print(\"X_train shape:\", X_train.shape)\n",
    "print(\"X_test shape:\", X_test.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "a1ce3a0e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:36:47.659143Z",
     "iopub.status.busy": "2025-12-13T13:36:47.658944Z",
     "iopub.status.idle": "2025-12-13T13:37:02.437377Z",
     "shell.execute_reply": "2025-12-13T13:37:02.436545Z"
    },
    "papermill": {
     "duration": 14.783187,
     "end_time": "2025-12-13T13:37:02.438807",
     "exception": false,
     "start_time": "2025-12-13T13:36:47.655620",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from sklearn.decomposition import PCA\n",
    "\n",
    "pca = PCA(n_components=100, random_state=42)\n",
    "X_train_reduced = pca.fit_transform(X_train)\n",
    "X_test_reduced  = pca.transform(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "a39acf23",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:37:02.446674Z",
     "iopub.status.busy": "2025-12-13T13:37:02.446369Z",
     "iopub.status.idle": "2025-12-13T13:37:02.450355Z",
     "shell.execute_reply": "2025-12-13T13:37:02.449746Z"
    },
    "papermill": {
     "duration": 0.008939,
     "end_time": "2025-12-13T13:37:02.451421",
     "exception": false,
     "start_time": "2025-12-13T13:37:02.442482",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X_train_reduced shape: (82404, 100)\n",
      "X_test_reduced shape: (224309, 100)\n"
     ]
    }
   ],
   "source": [
    "print(\"X_train_reduced shape:\", X_train_reduced.shape)\n",
    "print(\"X_test_reduced shape:\", X_test_reduced.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d7a499aa",
   "metadata": {
    "papermill": {
     "duration": 0.00268,
     "end_time": "2025-12-13T13:37:02.456898",
     "exception": false,
     "start_time": "2025-12-13T13:37:02.454218",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 3: Label encoding and Training\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "fbaccaef",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T13:37:02.463327Z",
     "iopub.status.busy": "2025-12-13T13:37:02.463133Z",
     "iopub.status.idle": "2025-12-13T14:32:45.547888Z",
     "shell.execute_reply": "2025-12-13T14:32:45.547091Z"
    },
    "papermill": {
     "duration": 3343.094463,
     "end_time": "2025-12-13T14:32:45.554221",
     "exception": false,
     "start_time": "2025-12-13T13:37:02.459758",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Training models:   0%|          | 0/3 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "y_train shape for P ontology: (82404, 16858) \t Number of unique P terms: 16858\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Training models:  33%|███▎      | 1/3 [35:41<1:11:23, 2141.97s/it]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model for P trained successfully.\n",
      "y_train shape for C ontology: (82404, 2651) \t Number of unique C terms: 2651\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Training models:  67%|██████▋   | 2/3 [41:47<18:17, 1097.11s/it]  "
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model for C trained successfully.\n",
      "y_train shape for F ontology: (82404, 6616) \t Number of unique F terms: 6616\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Training models: 100%|██████████| 3/3 [55:40<00:00, 1113.62s/it]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model for F trained successfully.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "from sklearn.preprocessing import MultiLabelBinarizer\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.multiclass import OneVsRestClassifier\n",
    "from tqdm import tqdm\n",
    "\n",
    "mlb_dict = dict()\n",
    "models = dict()\n",
    "\n",
    "train_terms_df = pd.read_csv(TRAIN_TERMS, sep=\"\\t\")\n",
    "\n",
    "for aspect in tqdm(['P', 'C', 'F'], desc=\"Training models\"):\n",
    "    # Filter the train_terms_df based on aspect\n",
    "    ont_terms_df = train_terms_df[train_terms_df['aspect'] == aspect]\n",
    "\n",
    "    # Group the dataFrame based on the EntryID, turn all the GO terms to a list, finally turns this dataFrame to a dict {entryID: terms}\n",
    "    protein_terms = ont_terms_df.groupby('EntryID')['term'].apply(list).to_dict()\n",
    "\n",
    "    # Create a list of labels for this aspect, if an entryID doesn't exist in this aspect, give it a []\n",
    "    # This ensures y_train is of shape (82404, ...)\n",
    "    labels = [protein_terms.get(entry_id, []) for entry_id in train_ids]\n",
    "\n",
    "    # Multi-hot encoding, use sparse representation\n",
    "    mlb = MultiLabelBinarizer(sparse_output=True)\n",
    "    y_train = mlb.fit_transform(labels)\n",
    "    \n",
    "    print(f\"y_train shape for {aspect} ontology: {y_train.shape} \\t Number of unique {aspect} terms: {y_train.shape[1]}\")\n",
    "\n",
    "    # Save to dict\n",
    "    mlb_dict[aspect] = mlb\n",
    "    model = OneVsRestClassifier(LogisticRegression(max_iter=600, solver='lbfgs', C=0.5, random_state=42), n_jobs=-1)\n",
    "    model.fit(X_train_reduced, y_train)\n",
    "    models[aspect] = model\n",
    "    print(f\"Model for {aspect} trained successfully.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7eee1adb",
   "metadata": {
    "papermill": {
     "duration": 0.003158,
     "end_time": "2025-12-13T14:32:45.561563",
     "exception": false,
     "start_time": "2025-12-13T14:32:45.558405",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 4: Inference and Submission"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "784521fc",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T14:32:45.569421Z",
     "iopub.status.busy": "2025-12-13T14:32:45.568777Z",
     "iopub.status.idle": "2025-12-13T14:46:00.575595Z",
     "shell.execute_reply": "2025-12-13T14:46:00.574746Z"
    },
    "papermill": {
     "duration": 795.01201,
     "end_time": "2025-12-13T14:46:00.576692",
     "exception": false,
     "start_time": "2025-12-13T14:32:45.564682",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Predicting on Test Set: 100%|██████████| 45/45 [13:14<00:00, 17.67s/it]\n"
     ]
    }
   ],
   "source": [
    "BATCH_SIZE = 5000  # avoid memory overflow\n",
    "submission_list = []\n",
    "\n",
    "for i in tqdm(range(0, len(test_ids), BATCH_SIZE), desc=\"Predicting on Test Set\"):\n",
    "    batch_entry_ids = test_ids[i : i + BATCH_SIZE]\n",
    "\n",
    "    X_batch = X_test_reduced[i : i + BATCH_SIZE]\n",
    "\n",
    "    for aspect, model in models.items():\n",
    "        mlb = mlb_dict[aspect]\n",
    "        y_pred_proba = model.predict_proba(X_batch)\n",
    "\n",
    "        for j, entry_id in enumerate(batch_entry_ids):\n",
    "            probs = y_pred_proba[j]\n",
    "            candidate_indices = np.where(probs > 0.02)[0]\n",
    "\n",
    "            for idx in candidate_indices:\n",
    "                submission_list.append((entry_id, mlb.classes_[idx], round(probs[idx], 3)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "185717d6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-13T14:46:00.588940Z",
     "iopub.status.busy": "2025-12-13T14:46:00.588262Z",
     "iopub.status.idle": "2025-12-13T14:46:11.959463Z",
     "shell.execute_reply": "2025-12-13T14:46:11.958630Z"
    },
    "papermill": {
     "duration": 11.378444,
     "end_time": "2025-12-13T14:46:11.960549",
     "exception": false,
     "start_time": "2025-12-13T14:46:00.582105",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Applying 1500 prediction limit per protein...\n",
      "\n",
      "Submission file 'submission.tsv' created successfully.\n",
      "Total predictions in final submission: 5,430,180\n",
      "Submission DataFrame Head:\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Protein Id</th>\n",
       "      <th>GO Term Id</th>\n",
       "      <th>Prediction</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>A0A017SE81</td>\n",
       "      <td>GO:0005777</td>\n",
       "      <td>0.110</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>A0A017SE81</td>\n",
       "      <td>GO:0005515</td>\n",
       "      <td>0.104</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>A0A017SE81</td>\n",
       "      <td>GO:0005829</td>\n",
       "      <td>0.099</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>A0A017SE81</td>\n",
       "      <td>GO:0005783</td>\n",
       "      <td>0.087</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>A0A017SE81</td>\n",
       "      <td>GO:0005886</td>\n",
       "      <td>0.081</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   Protein Id  GO Term Id  Prediction\n",
       "0  A0A017SE81  GO:0005777       0.110\n",
       "1  A0A017SE81  GO:0005515       0.104\n",
       "2  A0A017SE81  GO:0005829       0.099\n",
       "3  A0A017SE81  GO:0005783       0.087\n",
       "4  A0A017SE81  GO:0005886       0.081"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "submission_df = pd.DataFrame(submission_list, columns=['Protein Id', 'GO Term Id', 'Prediction'])\n",
    "\n",
    "print(\"Applying 1500 prediction limit per protein...\")\n",
    "submission_df = submission_df.sort_values(by=['Protein Id', 'Prediction'], ascending=[True, False])\n",
    "final_submission_df = submission_df.groupby('Protein Id').head(1500).reset_index(drop=True)\n",
    "final_submission_df.to_csv('submission.tsv', sep='\\t', index=False, header=False)\n",
    "\n",
    "print(\"\\nSubmission file 'submission.tsv' created successfully.\")\n",
    "print(f\"Total predictions in final submission: {len(final_submission_df):,}\")\n",
    "print(\"Submission DataFrame Head:\")\n",
    "display(final_submission_df.head())"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "nvidiaTeslaT4",
   "dataSources": [
    {
     "databundleVersionId": 14875579,
     "sourceId": 116062,
     "sourceType": "competition"
    },
    {
     "datasetId": 8917191,
     "sourceId": 13991224,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 9012019,
     "sourceId": 14141413,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31192,
   "isGpuEnabled": true,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 4186.355603,
   "end_time": "2025-12-13T14:46:14.582383",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-12-13T13:36:28.226780",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
